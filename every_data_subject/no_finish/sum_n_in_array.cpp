//给定一个有n个正整数的数组A和一个整数sum,求选择数组A中部分数字和为sum的方案数。
//当两种选取方案有一个数字的下标不一样,我们就认为是不同的组成方案。
//输入描述:
//输入为两行:
// 第一行为两个正整数n(1 ≤ n ≤ 1000)，sum(1 ≤ sum ≤ 1000)
//     第二行为n个正整数A[i](32位整数)，以空格隔开。
//     输出描述:
//     输出所求的方案数
//     示例1
//     输入
//     5 15
//     5 5 10 2 3
//     输出
//     4


//思路：
//首先设置一维数组存放要输入的元素个数
//因为前i个元素中和为j的方案=前i-1个元素中和为j - A[i]的元素个数 + 前i-1个元素中和为j的元素之和
//所以设置一个二维数组存放前n个（包含n）个元素中和从0到sum的方案个数
//因为计算第一个实际元素时，需要用到前一个元素的各项和的方案个数
//如果将第一个实际元素存放在数组下标为0的位置，此时就需要获取下标为-1的元素对应的各项和的方案个数
//此时就会使数组下标越界，所以使第一个实际元素存放在下标为1的位置
//下标为0的位置存放0，此时下标为0处的和为0的方案个数为1，其余和的方案个数均为0
//如果计算下标为1的各项和的方案数：如果和与下标为1的元素相等，就相当于在下标为0的各项和中找和为0的方案个数
//此时，方案数为1，正好满足，如果和大于下标为1的元素，就相当于在下标为0的各项和中找和值大于0（一部分）的方案个数
//此时，方案个数为0，也满足条件。
//如果和小于下标为1的元素，相当于在下标为0的各项和中找和值为各项和的方案个数


#include<iostream>
using namespace std;
int main()
{
    //定义一个一维数组存放n个正整数
    int A[1001];
    //定义一个二维数组用于存放前i个数和为j的方案个数（0<j<=sum）
    int dp[1001][1001];
    int n;
    int sum;
    cin>>n>>sum;
    int i;
    for(i = 1;i <= n;i++)
    {
        cin>>A[i];
    }
    //将A[0]的值设置为0，所以前0个数中，和为0的个数为1，和为其他数的个数为0；
    A[0] = 0;
    for(i = 1;i <= sum;i++)
    {
        dp[0][i] = 0;
    }
    dp[0][0] = 1;
    int j = 0;
    for(i = 1;i <= n;i++)
    {
        for(j = 0;j <= sum;j++)
        {
            if(j >= A[i])
            {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - A[i]];
            }
            else
            {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    cout<<dp[n][sum]<<endl;
    return 0;
}
